(lila-ws) Incoming User Move From Browser:

    FrameHandler:27 channelRead0
        msg = ClientOut:107 parse
        RoundClientActor ! msg

    RoundClientActor:111 receives msg of type ClientOut.RoundMove
        clientIn(ClientIn.Ack(ackId))
        lilaIn.round(LilaIn.RoundMove(fid, uci, blur, lag))



(lila) Incoming User Move From lila-ws
io.lettuce.core.pubsub.PubSubEndpoint:180 #notifyListeners
    lila.socket.RemoteSocket:117 #subscribe
            lila.round.RoundSocket:152 remoteSocketApi.subscribe("r-in", Protocol.In.reader)(
                                            roundHandler orElse remoteSocketApi.baseHandler
                                          ) >>- send(P.Out.boot)
                lila.round.RoundSocket:237 #reader
                    lila.round.RoundSocket:263 # PlayerMove(...)
                lila.round.RoundSocket:88 #roundHandler
                    lila.round.RoundSocket:90 #tellRound(fullId.gameId, HumanPlay(fullId.playerId, uci, blur, lag, none))
                        lila.round.RoundSocket:86 #tellRound
                            lila.hub.DuctConcMap:18 #tell  ductByGameId ! msg
                                lila.round.RoundDuct:111   val process: Duct.ReceiveAsync = {
                                    lila.round.RoundDuct:224   case p: HumanPlay =>

                                              // Loads lila.game.Game from game cache
                                              // Wraps the game in the POV of the current player
                                              // Runs the block of code with the POV as the argument
                                              // The block of code returns a Fu[Events], which the handle() method then publishes

                                              // handle(playerId: ID)(f: (pov) => Fu[Events]) under the hood calls:
                                              // proxy.withPov(playerId) { pov => publishEvents(f(pov)) } -- it's this publishing that seems to affect the game.
                                              // And f(p: POV):
                                              //       - Uses scalachess to apply the move to the pov.game in memory
                                              //       - Updates the GameProxy.cache with the new state in memory
                                              //       - Asks GameProxy to asynchronously flush the new state to the mongo game5 collection

                                              handle(p.playerId) { pov =>
                                                  [...]
                                                  if (pov.game.outoftime(withGrace = true)) finisher.outOfTime(pov.game)
                                                  else player.human(p, this)(pov)
                                                      applyUci(game, uci, blur, lag)
                                                        .flatMap {
                                                          case Flagged => finisher.outOfTime(game)
                                                          case MoveApplied(progress, moveOrDrop) =>
                                                            proxy.save(progress) >>
                                                              postHumanOrBotPlay(round, pov, progress, moveOrDrop)
                                                                    Player#notifyMove()
                                                                         lila.common.Bus.publish(MoveGameEvent) // Unclear who receives these...
                                                                         return Fu[Events] with a List(Event.Move) // To be published by the caller, this event is what affects players
                                                        }



... May want to check in RoundDuct for flagging, as there are some flagging-related messages in there.





(lila-ws) Incoming FEN from Lila:
io.lettuce.core.pubsub.PubSubEndpoint:180 notifyListeners()
    lila.ws.Lila:117 anonymous instance of RedisPubSubAdapter#message
        LilaOut:236 #read()
            LilaOut:252 RoundVersion.apply()
        LilaHandler:124 roundHandler
            case RoundVersion(gameId, version, flags, tpe, data) =>
                  val versioned = ClientIn.RoundVersioned(version, flags, tpe, data)
                  lila.ws.History.round.add(gameId, versioned)
                  lila.ws.Bus.publish(_ room gameId, versioned) # This is what actually sends the move and resulting position to the players
                  lila.ws.Fens.move(gameId, data)

